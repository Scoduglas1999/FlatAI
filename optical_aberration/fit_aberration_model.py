import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression

# --- I. SCRIPT CONFIGURATION ---

# Path to the aberration map CSV file generated by the previous script
ABERRATION_MAP_PATH = "./aberration_map.csv"

# The dimensions of the sensor used to create the aberration map.
# This is crucial for correctly normalizing coordinates.
# Example: ZWO ASI1600MM
IMAGE_WIDTH = 4656
IMAGE_HEIGHT = 3520

# Path to save the output visualization plot
PLOT_SAVE_PATH = "./coma_field_visualization.png"


# --- II. HELPER FUNCTIONS ---

def load_aberration_data(csv_path):
    """
    Loads the aberration map data from a CSV file.
    
    Args:
        csv_path (str): The path to the aberration_map.csv file.
        
    Returns:
        pd.DataFrame or None: The loaded data as a pandas DataFrame, or None if
                              the file is not found.
    """
    try:
        print(f"Loading aberration map from: {csv_path}")
        df = pd.read_csv(csv_path)
        print(f"Successfully loaded {len(df)} data points.")
        return df
    except FileNotFoundError:
        print(f"Error: The file was not found at {csv_path}")
        print("Please ensure you have generated the aberration map first.")
        return None

def visualize_coma_field(df, width, height, save_path):
    """
    Creates and saves a quiver plot to visualize the coma field.
    
    The arrows point in the direction of the coma aberration, and their length
    represents its magnitude. This helps visualize field tilt and other issues.
    
    Args:
        df (pd.DataFrame): DataFrame containing star coordinates and predictions.
        width (int): The width of the original image sensor.
        height (int): The height of the original image sensor.
        save_path (str): The path to save the output plot image.
    """
    print("Generating coma field visualization...")
    
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(10, 8))
    
    # Create the quiver plot. The 'pred_z7' and 'pred_z8' are the U and V
    # vector components for the arrows.
    ax.quiver(df['x_coord'], df['y_coord'], df['pred_z7'], df['pred_z8'],
              color='cyan', scale=1, scale_units='xy', angles='xy')
    
    ax.set_aspect('equal')
    ax.set_xlim(0, width)
    ax.set_ylim(0, height)
    ax.invert_yaxis()  # Match image coordinate systems (origin at top-left)
    
    ax.set_title('Visualization of Coma Field (Z7/Z8)')
    ax.set_xlabel('X Pixel Coordinate')
    ax.set_ylabel('Y Pixel Coordinate')
    
    plt.grid(True, linestyle='--', alpha=0.5)
    plt.savefig(save_path, dpi=300)
    print(f"Plot saved to: {save_path}")
    plt.show()

def fit_aberration_model(df, width, height):
    """
    Fits a linear model to the aberration data to describe the field.
    
    This function models how coma (Z7, Z8) changes as a function of field
    position (x, y). The resulting coefficients provide a mathematical
    description of the optical system's field-dependent aberrations.
    
    Args:
        df (pd.DataFrame): DataFrame containing the aberration data.
        width (int): The width of the image sensor.
        height (int): The height of the image sensor.
        
    Returns:
        tuple: A tuple containing the two fitted LinearRegression models
               (model_z7, model_z8).
    """
    print("\nFitting linear model to aberration field...")
    
    # 1. Prepare the data
    # Normalize coordinates to a [-1, 1] range. This is standard practice for
    # fitting models and makes the coefficients more interpretable.
    x_norm = (df['x_coord'] - width / 2) / (width / 2)
    y_norm = (df['y_coord'] - height / 2) / (height / 2)
    
    # Feature matrix X contains the normalized positions
    X = pd.DataFrame({'x_norm': x_norm, 'y_norm': y_norm})
    
    # Target vectors y contain the Zernike coefficients we want to model
    y_z7 = df['pred_z7']
    y_z8 = df['pred_z8']
    
    # 2. Fit two separate linear models
    model_z7 = LinearRegression()
    model_z8 = LinearRegression()
    
    model_z7.fit(X, y_z7)
    model_z8.fit(X, y_z8)
    
    # 3. Output the results
    print("\n--- Aberration Field Model Results ---")
    print("The model is of the form: Z = a*x_norm + b*y_norm + c")
    
    coef_z7 = model_z7.coef_
    intercept_z7 = model_z7.intercept_
    print(f"\nComa X (Z7) Fit: Z7 = {coef_z7[0]:.4f}*x + {coef_z7[1]:.4f}*y + {intercept_z7:.4f}")
    
    coef_z8 = model_z8.coef_
    intercept_z8 = model_z8.intercept_
    print(f"Coma Y (Z8) Fit: Z8 = {coef_z8[0]:.4f}*x + {coef_z8[1]:.4f}*y + {intercept_z8:.4f}")
    
    print("\nInterpretation:")
    print("- The intercept ('c') represents the coma at the exact center of the field.")
    print("- The 'a' and 'b' coefficients show how much coma changes as you move along the X and Y axes.")
    
    return model_z7, model_z8


# --- III. MAIN EXECUTION LOGIC ---

if __name__ == "__main__":
    # 1. Load the data
    aberration_df = load_aberration_data(ABERRATION_MAP_PATH)
    
    if aberration_df is not None and not aberration_df.empty:
        # 2. Visualize the raw data field
        visualize_coma_field(aberration_df, IMAGE_WIDTH, IMAGE_HEIGHT, PLOT_SAVE_PATH)
        
        # 3. Fit the mathematical model
        fit_aberration_model(aberration_df, IMAGE_WIDTH, IMAGE_HEIGHT)
    else:
        print("Could not proceed with analysis due to missing or empty data file.") 